#!/usr/bin/env <%= @ruby_path %>

require "bundler/setup"
require "fileutils"
require "rack"
require 'rackup/handler/webrick'
require "webrick"
require "webrick/https"
require "openssl"
require "securerandom"
require "redis"
require "logger"
require "json"
require 'stringio'

require_relative "../lib/model_context_protocol"

# Only require test handler files (prompts, resources, tools, etc.), not RSpec helpers
%w[prompts resources resource_templates tools completions].each do |subdir|
  Dir[File.join(__dir__, "../spec/support/#{subdir}/**/*.rb")].each { |file| require file }
end

logger = Logger.new(STDOUT)
logger.level = Logger::INFO
logger.formatter = proc do |severity, datetime, progname, msg|
  request_id = Thread.current[:request_id] || "----"
  "[#{datetime.strftime('%Y-%m-%d %H:%M:%S')}] #{severity} [#{request_id}]: #{msg}\n"
end

# Flag files for dynamic handler registration (checked at startup)
# Touch these files BEFORE starting the server to add extra handlers:
#   tmp/flags/extra_tools    - adds TestToolWithAudioResponse
#   tmp/flags/extra_resources - adds TestBinaryResource
#   tmp/flags/extra_prompts  - adds TestPromptWithCompletionClass
FLAGS_DIR = File.join(__dir__, '..', 'tmp', 'flags')
FileUtils.mkdir_p(FLAGS_DIR) unless Dir.exist?(FLAGS_DIR)

def flag_enabled?(flag_name)
  File.exist?(File.join(FLAGS_DIR, flag_name))
end

# Configure Redis
ModelContextProtocol::Server.configure_redis do |config|
  config.redis_url = "redis://localhost:6379/0"
  config.pool_size = 10
  config.enable_reaper = true
  config.reaper_interval = 10
  config.idle_timeout = 15
end

# Configure server logging
ModelContextProtocol::Server.configure_server_logging do |config|
  config.logdev = $stdout
  config.level = Logger::DEBUG
  config.progname = "MCP-Dev-Server"
end

# Build the registry (checks flag files at startup)
def build_registry
  ModelContextProtocol::Server::Registry.new do
    prompts do
      register TestPrompt
      register TestPromptWithCompletionClass if flag_enabled?('extra_prompts')
    end

    resources subscribe: true do
      register TestResource
      register TestAnnotatedResource
      register TestProgressiveResource
      register TestBinaryResource if flag_enabled?('extra_resources')
    end

    resource_templates do
      register TestResourceTemplate
    end

    tools do
      register TestToolWithStructuredContentResponse
      register TestToolWithTextResponse
      register TestToolWithImageResponse
      register TestToolWithMixedContentResponse
      register TestToolWithResourceResponse
      register TestToolWithToolErrorResponse
      register TestToolWithCancellableSleep
      register TestToolWithProgressableAndCancellable
      register TestToolWithAudioResponse if flag_enabled?('extra_tools')
    end
  end
end

# Set up the singleton server (runs once at startup)
logger.info("Setting up MCP Server singleton...")
ModelContextProtocol::Server.setup do |config|
  config.name = "MCP Development Server"
  config.version = "1.0.0"

  config.pagination = {
    default_page_size: 2,
    max_page_size: 3,
    cursor_ttl: 1800
  }

  config.transport = {
    type: :streamable_http,
    require_sessions: true,
    session_ttl: 3600,
    allowed_origins: ["*"]
  }

  config.registry = build_registry
end

class MCPHttpApp
  def initialize(logger)
    @logger = logger
  end

  def call(env)
    request_id = SecureRandom.hex(4)
    Thread.current[:request_id] = request_id

    request = Rack::Request.new(env)
    body_content = request.body.read

    case env['REQUEST_METHOD']
    when 'POST'
      begin
        request_json = JSON.parse(body_content)
        method = request_json['method']
        id = request_json['id']

        if method&.start_with?('notifications/')
          @logger.info("→ #{method} [NOTIFICATION]")
        elsif id.nil?
          @logger.info("→ #{method} [NOTIFICATION]")
        else
          @logger.info("→ #{method} (id: #{id}) [REQUEST]")
        end
        @logger.info("  Request: #{body_content}")
      rescue JSON::ParserError
        @logger.info("→ POST #{env['PATH_INFO']} [INVALID JSON]")
        @logger.info("  Request: #{body_content}")
      end
    when 'GET'
      accept_header = env['HTTP_ACCEPT'] || ''
      if accept_header.include?('text/event-stream')
        @logger.info("→ GET #{env['PATH_INFO']} [SSE STREAM REQUEST]")
      else
        @logger.info("→ GET #{env['PATH_INFO']}")
      end
      @logger.info("  Headers: Accept=#{accept_header}") unless accept_header.empty?
    when 'DELETE'
      session_id = env['HTTP_MCP_SESSION_ID']
      if session_id
        @logger.info("→ DELETE #{env['PATH_INFO']} [SESSION CLEANUP: #{session_id}]")
      else
        @logger.info("→ DELETE #{env['PATH_INFO']} [SESSION CLEANUP]")
      end
    else
      @logger.info("→ #{env['REQUEST_METHOD']} #{env['PATH_INFO']}")
      @logger.info("  Request: #{body_content}") unless body_content.empty?
    end

    if ModelContextProtocol::Server::RedisConfig.configured?
      pool_stats = ModelContextProtocol::Server::RedisConfig.stats
      @logger.info("  Redis Pool: #{pool_stats}")
    end

    env['rack.input'] = StringIO.new(body_content)
    request = Rack::Request.new(env)

    unless request.path == "/mcp"
      return [404, {"Content-Type" => "application/json"}, ['{"error": "Not found"}']]
    end

    if request.request_method == "OPTIONS"
      return [200, {
        "Access-Control-Allow-Origin" => "*",
        "Access-Control-Allow-Methods" => "GET, POST, DELETE, OPTIONS",
        "Access-Control-Allow-Headers" => "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin",
        "Access-Control-Max-Age" => "86400"
      }, [""]]
    end

    begin
      @logger.debug("Handling request via Server.serve")

      # Use the singleton server to handle the request
      result = ModelContextProtocol::Server.serve(
        env: env,
        session_context: {
          user_id: "dev-user-123",
          request_id: request_id
        }
      )

      case result
      when Hash
        if result[:stream]
          @logger.info("← SSE STREAM OPENED [PERSISTENT CONNECTION]")
          @logger.info("  Connection will remain open for real-time notifications")
          headers = result[:headers] || {}
          headers["Access-Control-Allow-Origin"] = "*"
          headers["Access-Control-Allow-Methods"] = "GET, POST, DELETE, OPTIONS"
          headers["Access-Control-Allow-Headers"] = "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin"

          return [200, headers, result[:stream_proc]]
        elsif result[:json]
          response_body = result[:json].to_json
          status = result[:status] || 200

          begin
            response_json = result[:json]
            if response_json[:error]
              @logger.info("← ERROR RESPONSE (code: #{response_json[:error][:code]})")
            elsif status == 202
              @logger.info("← NOTIFICATION ACCEPTED [NO RESPONSE REQUIRED]")
            elsif response_json[:accepted] == true && status == 200
              method = request_json['method'] rescue 'unknown'
              id = request_json['id'] rescue 'unknown'
              @logger.info("← #{method} RESPONSE (id: #{id}) [DELIVERED VIA SSE STREAM]")
            elsif response_json[:result]
              method = request_json['method'] rescue 'unknown'
              @logger.info("← #{method} RESPONSE (id: #{response_json[:id]})")
            else
              @logger.info("← RESPONSE (status: #{status})")
            end
            @logger.info("  Response: #{response_body}") unless status == 202 && response_body == '{}'
          rescue
            @logger.info("← RESPONSE (status: #{status})")
            @logger.info("  Response: #{response_body}") unless response_body.empty?
          end

          headers = result[:headers] || {}
          headers["Content-Type"] = "application/json"
          headers["Access-Control-Allow-Origin"] = "*"
          headers["Access-Control-Allow-Methods"] = "GET, POST, DELETE, OPTIONS"
          headers["Access-Control-Allow-Headers"] = "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin"

          [result[:status] || 200, headers, [response_body]]
        else
          # Fallback
          @logger.error("← Invalid transport response")
          [500, {"Content-Type" => "application/json"}, ['{"error": "Invalid transport response"}']]
        end
      else
        @logger.error("← Unexpected response format")
        [500, {"Content-Type" => "application/json"}, ['{"error": "Unexpected response format"}']]
      end
    rescue => e
      @logger.error("Error handling request: #{e.message}")
      @logger.debug("Full backtrace:\n#{e.backtrace.join("\n")}")
      [500, {"Content-Type" => "application/json"}, [%Q({"error": "Internal server error: #{e.message}"})]]
    ensure
      Thread.current[:request_id] = nil
    end
  end
end

use_ssl = ENV['SSL'] == 'true'
port = use_ssl ? 9293 : 9292
protocol = use_ssl ? 'https' : 'http'

logger.info("Starting MCP #{protocol.upcase} Development Server on #{protocol}://localhost:#{port}/mcp")
logger.info("Using singleton transport pattern (2 background threads max)")
logger.info("")
logger.info("Flag files (checked at startup only - restart server to apply changes):")
logger.info("  touch tmp/flags/extra_tools     # Add TestToolWithAudioResponse")
logger.info("  touch tmp/flags/extra_resources # Add TestBinaryResource")
logger.info("  touch tmp/flags/extra_prompts   # Add TestPromptWithCompletionClass")
logger.info("  rm tmp/flags/<flag>             # Remove the handler")

app = Rack::Builder.new do
  map '/mcp' do
    run MCPHttpApp.new(logger)
  end
end

server_options = {
  Port: port,
  Host: '0.0.0.0'
}

if use_ssl
  cert_path = File.join(__dir__, '..', 'tmp', 'ssl', 'server.crt')
  key_path = File.join(__dir__, '..', 'tmp', 'ssl', 'server.key')

  unless File.exist?(cert_path) && File.exist?(key_path)
    logger.error("SSL certificates not found at tmp/ssl/")
    logger.error("Generate them with: openssl req -x509 -newkey rsa:4096 -keyout tmp/ssl/server.key -out tmp/ssl/server.crt -days 365 -nodes -subj \"/C=US/ST=Dev/L=Dev/O=Dev/CN=localhost\"")
    exit(1)
  end

  server_options.merge!(
    SSLEnable: true,
    SSLCertificate: OpenSSL::X509::Certificate.new(File.read(cert_path)),
    SSLPrivateKey: OpenSSL::PKey::RSA.new(File.read(key_path)),
    SSLVerifyClient: OpenSSL::SSL::VERIFY_NONE
  )
end

webrick_server = WEBrick::HTTPServer.new(server_options)
webrick_server.mount '/', Rackup::Handler::WEBrick, app

['INT', 'TERM'].each do |signal|
  Signal.trap(signal) do
    logger.info("Shutting down...")
    ModelContextProtocol::Server.shutdown
    webrick_server.shutdown
    exit(0)
  end
end

webrick_server.start

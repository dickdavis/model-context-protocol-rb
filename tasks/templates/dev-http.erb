#!/usr/bin/env <%= @ruby_path %>

require "bundler/setup"
require "rack"
require 'rackup/handler/webrick'
require "webrick"
require "securerandom"
require "redis"
require "logger"
require "json"
require 'stringio'

require_relative "../lib/model_context_protocol"

Dir[File.join(__dir__, "../spec/support/**/*.rb")].each { |file| require file }

logger = Logger.new(STDOUT)
logger.level = Logger::INFO
logger.formatter = proc do |severity, datetime, progname, msg|
  request_id = Thread.current[:request_id] || "----"
  "[#{datetime.strftime('%Y-%m-%d %H:%M:%S')}] #{severity} [#{request_id}]: #{msg}\n"
end


class MCPHttpApp
  def initialize(logger)
    @logger = logger
  end

  def call(env)
    request_id = SecureRandom.hex(4)
    Thread.current[:request_id] = request_id

    request = Rack::Request.new(env)
    body_content = request.body.read

    case env['REQUEST_METHOD']
    when 'POST'
      begin
        request_json = JSON.parse(body_content)
        method = request_json['method']
        id = request_json['id']

        if method&.start_with?('notifications/')
          @logger.info("→ #{method} [NOTIFICATION]")
        elsif id.nil?
          @logger.info("→ #{method} [NOTIFICATION]")
        else
          @logger.info("→ #{method} (id: #{id}) [REQUEST]")
        end
        @logger.info("  Request: #{body_content}")
      rescue JSON::ParserError
        @logger.info("→ POST #{env['PATH_INFO']} [INVALID JSON]")
        @logger.info("  Request: #{body_content}")
      end
    when 'GET'
      accept_header = env['HTTP_ACCEPT'] || ''
      if accept_header.include?('text/event-stream')
        @logger.info("→ GET #{env['PATH_INFO']} [SSE STREAM REQUEST]")
      else
        @logger.info("→ GET #{env['PATH_INFO']}")
      end
      @logger.info("  Headers: Accept=#{accept_header}") unless accept_header.empty?
    when 'DELETE'
      session_id = env['HTTP_MCP_SESSION_ID']
      if session_id
        @logger.info("→ DELETE #{env['PATH_INFO']} [SESSION CLEANUP: #{session_id}]")
      else
        @logger.info("→ DELETE #{env['PATH_INFO']} [SESSION CLEANUP]")
      end
    else
      @logger.info("→ #{env['REQUEST_METHOD']} #{env['PATH_INFO']}")
      @logger.info("  Request: #{body_content}") unless body_content.empty?
    end

    env['rack.input'] = StringIO.new(body_content)
    request = Rack::Request.new(env)

    unless request.path == "/mcp"
      return [404, {"Content-Type" => "application/json"}, ['{"error": "Not found"}']]
    end

    if request.request_method == "OPTIONS"
      return [200, {
        "Access-Control-Allow-Origin" => "*",
        "Access-Control-Allow-Methods" => "GET, POST, DELETE, OPTIONS",
        "Access-Control-Allow-Headers" => "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin",
        "Access-Control-Max-Age" => "86400"
      }, [""]]
    end

    begin
      redis_client = Redis.new(url: ENV.fetch("REDIS_URL", "redis://localhost:6379/0"))
      @logger.debug("Testing Redis connection...")
      redis_client.ping
      @logger.info("Redis connected successfully")
    end

    transport_config = {
      type: :streamable_http,
      env: env,
      redis_client: redis_client,
      require_sessions: false,  # Optional sessions for easier testing
      session_ttl: 3600,
      validate_origin: false,   # Disable for testing
      allowed_origins: ["*"]
    }

    @logger.debug("Creating MCP server with transport config")
    server = create_mcp_server(transport_config)

    begin
      @logger.debug("Starting MCP server")
      result = server.start

      case result
      when Hash
        if result[:stream]
          @logger.info("← SSE STREAM OPENED [PERSISTENT CONNECTION]")
          @logger.info("  Connection will remain open for real-time notifications")
          headers = result[:headers] || {}
          headers["Access-Control-Allow-Origin"] = "*"
          headers["Access-Control-Allow-Methods"] = "GET, POST, DELETE, OPTIONS"
          headers["Access-Control-Allow-Headers"] = "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin"

          return [200, headers, result[:stream_proc]]
        elsif result[:json]
          response_body = result[:json].to_json
          status = result[:status] || 200

          begin
            response_json = result[:json]
            if response_json[:error]
              @logger.info("← ERROR RESPONSE (code: #{response_json[:error][:code]})")
            elsif status == 202
              @logger.info("← NOTIFICATION ACCEPTED [NO RESPONSE REQUIRED]")
            elsif response_json[:result]
              method = request_json['method'] rescue 'unknown'
              @logger.info("← #{method} RESPONSE (id: #{response_json[:id]})")
            else
              @logger.info("← RESPONSE (status: #{status})")
            end
            @logger.info("  Response: #{response_body}") unless status == 202 && response_body == '{}'
          rescue
            @logger.info("← RESPONSE (status: #{status})")
            @logger.info("  Response: #{response_body}") unless response_body.empty?
          end

          headers = result[:headers] || {}
          headers["Content-Type"] = "application/json"
          headers["Access-Control-Allow-Origin"] = "*"
          headers["Access-Control-Allow-Methods"] = "GET, POST, DELETE, OPTIONS" 
          headers["Access-Control-Allow-Headers"] = "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin"

          [result[:status] || 200, headers, [response_body]]
        else
          # Fallback
          @logger.error("← Invalid transport response")
          [500, {"Content-Type" => "application/json"}, ['{"error": "Invalid transport response"}']]
        end
      else
        @logger.error("← Unexpected response format")
        [500, {"Content-Type" => "application/json"}, ['{"error": "Unexpected response format"}']]
      end
    rescue => e
      @logger.error("Error handling request: #{e.message}")
      @logger.debug("Full backtrace:\n#{e.backtrace.join("\n")}")
      [500, {"Content-Type" => "application/json"}, [%Q({"error": "Internal server error: #{e.message}"})]]
    ensure
      Thread.current[:request_id] = nil
    end
  end

  private

  def create_mcp_server(transport_config)
    ModelContextProtocol::Server.new do |config|
      config.name = "MCP Development Server"
      config.version = "1.0.0"
      config.logging_enabled = true

      config.pagination = {
        default_page_size: 2,
        max_page_size: 3,
        cursor_ttl: 1800
      }

      config.set_environment_variable("MCP_ENV", "development")

      config.context = {
        user_id: "123456",
        request_id: Thread.current[:request_id]
      }

      config.transport = transport_config

      config.registry = ModelContextProtocol::Server::Registry.new do
        prompts list_changed: true do
          register TestPrompt
          register TestPromptWithCompletionClass
        end

        resources list_changed: true, subscribe: true do
          register TestResource
          register TestAnnotatedResource
          register TestBinaryResource
        end

        resource_templates do
          register TestResourceTemplate
        end

        tools list_changed: true do
          register TestToolWithStructuredContentResponse
          register TestToolWithTextResponse
          register TestToolWithImageResponse
          register TestToolWithMixedContentResponse
          register TestToolWithResourceResponse
          register TestToolWithToolErrorResponse
        end
      end
    end
  end
end

logger.info("Starting MCP HTTP Development Server on http://localhost:9292/mcp")

app = Rack::Builder.new do
  map '/mcp' do
    run MCPHttpApp.new(logger)
  end
end

server = WEBrick::HTTPServer.new(Port: 9292, Host: '0.0.0.0')
server.mount '/', Rackup::Handler::WEBrick, app

['INT', 'TERM'].each do |signal|
  Signal.trap(signal) do
    server.shutdown
    exit(0)
  end
end

server.start
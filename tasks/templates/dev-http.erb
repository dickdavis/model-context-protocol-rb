#!/usr/bin/env <%= @ruby_path %>

require "bundler/setup"
require "rack"
require 'rackup/handler/webrick'
require "webrick"
require "webrick/https"
require "openssl"
require "securerandom"
require "redis"
require "logger"
require "json"
require 'stringio'

require_relative "../lib/model_context_protocol"

ModelContextProtocol::Server.configure_redis do |config|
  config.redis_url = "redis://localhost:6379/0"
  config.enable_reaper = true

  # Aggressive settings for development/debugging
  config.reaper_interval = 2    # Check every 2 seconds in dev
  config.idle_timeout = 5       # Close connections idle for 5+ seconds
end

Dir[File.join(__dir__, "../spec/support/**/*.rb")].each { |file| require file }

logger = Logger.new(STDOUT)
logger.level = Logger::INFO
logger.formatter = proc do |severity, datetime, progname, msg|
  request_id = Thread.current[:request_id] || "----"
  "[#{datetime.strftime('%Y-%m-%d %H:%M:%S')}] #{severity} [#{request_id}]: #{msg}\n"
end


class MCPHttpApp
  def initialize(logger)
    @logger = logger
  end

  def call(env)
    request_id = SecureRandom.hex(4)
    Thread.current[:request_id] = request_id

    request = Rack::Request.new(env)
    body_content = request.body.read

    case env['REQUEST_METHOD']
    when 'POST'
      begin
        request_json = JSON.parse(body_content)
        method = request_json['method']
        id = request_json['id']

        if method&.start_with?('notifications/')
          @logger.info("→ #{method} [NOTIFICATION]")
        elsif id.nil?
          @logger.info("→ #{method} [NOTIFICATION]")
        else
          @logger.info("→ #{method} (id: #{id}) [REQUEST]")
        end
        @logger.info("  Request: #{body_content}")
      rescue JSON::ParserError
        @logger.info("→ POST #{env['PATH_INFO']} [INVALID JSON]")
        @logger.info("  Request: #{body_content}")
      end
    when 'GET'
      accept_header = env['HTTP_ACCEPT'] || ''
      if accept_header.include?('text/event-stream')
        @logger.info("→ GET #{env['PATH_INFO']} [SSE STREAM REQUEST]")
      else
        @logger.info("→ GET #{env['PATH_INFO']}")
      end
      @logger.info("  Headers: Accept=#{accept_header}") unless accept_header.empty?
    when 'DELETE'
      session_id = env['HTTP_MCP_SESSION_ID']
      if session_id
        @logger.info("→ DELETE #{env['PATH_INFO']} [SESSION CLEANUP: #{session_id}]")
      else
        @logger.info("→ DELETE #{env['PATH_INFO']} [SESSION CLEANUP]")
      end
    else
      @logger.info("→ #{env['REQUEST_METHOD']} #{env['PATH_INFO']}")
      @logger.info("  Request: #{body_content}") unless body_content.empty?
    end

    env['rack.input'] = StringIO.new(body_content)
    request = Rack::Request.new(env)

    unless request.path == "/mcp"
      return [404, {"Content-Type" => "application/json"}, ['{"error": "Not found"}']]
    end

    if request.request_method == "OPTIONS"
      return [200, {
        "Access-Control-Allow-Origin" => "*",
        "Access-Control-Allow-Methods" => "GET, POST, DELETE, OPTIONS",
        "Access-Control-Allow-Headers" => "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin",
        "Access-Control-Max-Age" => "86400"
      }, [""]]
    end

    transport_config = {
      type: :streamable_http,
      env: env,
      require_sessions: false,  # Optional sessions for easier testing
      session_ttl: 3600,
      validate_origin: false,   # Disable for testing
      allowed_origins: ["*"]
    }

    @logger.debug("Creating MCP server with transport config")
    server = create_mcp_server(transport_config)
    transport = nil

    begin
      @logger.debug("Starting MCP server")
      result = server.start

      if server.respond_to?(:transport)
        transport = server.transport
      end

      case result
      when Hash
        if result[:stream]
          @logger.info("← SSE STREAM OPENED [PERSISTENT CONNECTION]")
          @logger.info("  Connection will remain open for real-time notifications")
          headers = result[:headers] || {}
          headers["Access-Control-Allow-Origin"] = "*"
          headers["Access-Control-Allow-Methods"] = "GET, POST, DELETE, OPTIONS"
          headers["Access-Control-Allow-Headers"] = "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin"

          return [200, headers, result[:stream_proc]]
        elsif result[:json]
          response_body = result[:json].to_json
          status = result[:status] || 200

          begin
            response_json = result[:json]
            if response_json[:error]
              @logger.info("← ERROR RESPONSE (code: #{response_json[:error][:code]})")
            elsif status == 202
              @logger.info("← NOTIFICATION ACCEPTED [NO RESPONSE REQUIRED]")
            elsif response_json[:result]
              method = request_json['method'] rescue 'unknown'
              @logger.info("← #{method} RESPONSE (id: #{response_json[:id]})")
            else
              @logger.info("← RESPONSE (status: #{status})")
            end
            @logger.info("  Response: #{response_body}") unless status == 202 && response_body == '{}'
          rescue
            @logger.info("← RESPONSE (status: #{status})")
            @logger.info("  Response: #{response_body}") unless response_body.empty?
          end

          headers = result[:headers] || {}
          headers["Content-Type"] = "application/json"
          headers["Access-Control-Allow-Origin"] = "*"
          headers["Access-Control-Allow-Methods"] = "GET, POST, DELETE, OPTIONS" 
          headers["Access-Control-Allow-Headers"] = "Content-Type, Accept, Mcp-Session-Id, MCP-Protocol-Version, Origin"

          [result[:status] || 200, headers, [response_body]]
        else
          # Fallback
          @logger.error("← Invalid transport response")
          [500, {"Content-Type" => "application/json"}, ['{"error": "Invalid transport response"}']]
        end
      else
        @logger.error("← Unexpected response format")
        [500, {"Content-Type" => "application/json"}, ['{"error": "Unexpected response format"}']]
      end
    rescue => e
      @logger.error("Error handling request: #{e.message}")
      @logger.debug("Full backtrace:\n#{e.backtrace.join("\n")}")
      [500, {"Content-Type" => "application/json"}, [%Q({"error": "Internal server error: #{e.message}"})]]
    ensure
      transport&.cleanup if transport&.respond_to?(:cleanup)
      Thread.current[:request_id] = nil
    end
  end

  private

  def create_mcp_server(transport_config)
    ModelContextProtocol::Server.new do |config|
      config.name = "MCP Development Server"
      config.version = "1.0.0"
      config.logging_enabled = true

      config.pagination = {
        default_page_size: 2,
        max_page_size: 3,
        cursor_ttl: 1800
      }

      config.set_environment_variable("MCP_ENV", "development")

      config.context = {
        user_id: "123456",
        request_id: Thread.current[:request_id]
      }

      config.transport = transport_config

      config.registry = ModelContextProtocol::Server::Registry.new do
        prompts list_changed: true do
          register TestPrompt
          register TestPromptWithCompletionClass
        end

        resources list_changed: true, subscribe: true do
          register TestResource
          register TestAnnotatedResource
          register TestBinaryResource
        end

        resource_templates do
          register TestResourceTemplate
        end

        tools list_changed: true do
          register TestToolWithStructuredContentResponse
          register TestToolWithTextResponse
          register TestToolWithImageResponse
          register TestToolWithMixedContentResponse
          register TestToolWithResourceResponse
          register TestToolWithToolErrorResponse
        end
      end
    end
  end
end

use_ssl = ENV['SSL'] == 'true'
port = use_ssl ? 9293 : 9292
protocol = use_ssl ? 'https' : 'http'

logger.info("Starting MCP #{protocol.upcase} Development Server on #{protocol}://localhost:#{port}/mcp")

app = Rack::Builder.new do
  map '/mcp' do
    run MCPHttpApp.new(logger)
  end
end

server_options = {
  Port: port,
  Host: '0.0.0.0'
}

if use_ssl
  cert_path = File.join(__dir__, '..', 'tmp', 'ssl', 'server.crt')
  key_path = File.join(__dir__, '..', 'tmp', 'ssl', 'server.key')

  unless File.exist?(cert_path) && File.exist?(key_path)
    logger.error("SSL certificates not found at tmp/ssl/")
    logger.error("Generate them with: openssl req -x509 -newkey rsa:4096 -keyout tmp/ssl/server.key -out tmp/ssl/server.crt -days 365 -nodes -subj \"/C=US/ST=Dev/L=Dev/O=Dev/CN=localhost\"")
    exit(1)
  end

  server_options.merge!(
    SSLEnable: true,
    SSLCertificate: OpenSSL::X509::Certificate.new(File.read(cert_path)),
    SSLPrivateKey: OpenSSL::PKey::RSA.new(File.read(key_path)),
    SSLVerifyClient: OpenSSL::SSL::VERIFY_NONE
  )
end

server = WEBrick::HTTPServer.new(server_options)
server.mount '/', Rackup::Handler::WEBrick, app

['INT', 'TERM'].each do |signal|
  Signal.trap(signal) do
    server.shutdown
    exit(0)
  end
end

server.start
